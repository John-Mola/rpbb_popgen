nest = NA_character_,
id2 = NA_character_) %>%
dplyr::select(unique_id, id2, caste, nest, floral_host, notes)
df_flt_hepner <- df_hepner %>%
dplyr::select(unique_id, caste, nest, floral_host, notes) %>%
mutate(id2 = NA_character_) %>%
dplyr::select(unique_id, id2, caste, nest, floral_host, notes)
df_flt_jean <- df_jean %>%
dplyr::select(unique_id, caste, nest, floral_host, notes) %>%
mutate(id2 = NA_character_) %>%
dplyr::select(unique_id, id2, caste, nest, floral_host, notes)
df_flt_kochanski <- df_kochanski %>%
dplyr::select(unique_id, caste, nest, floral_host, notes) %>%
mutate(id2 = NA_character_) %>%
dplyr::select(unique_id, id2, caste, nest, floral_host, notes)
df_flt_runquist <- df_runquist %>%
dplyr::select(unique_id, caste, nest, floral_host, notes) %>%
mutate(id2 = NA_character_) %>%
dplyr::select(unique_id, id2, caste, nest, floral_host, notes)
df_flt_watson <- df_watson %>%
dplyr::select(usda_tag, notes) %>%
rename(unique_id = usda_tag) %>%
mutate(caste = NA_character_,
nest = NA_character_,
id2 = NA_character_,
floral_host = NA_character_) %>%
dplyr::select(unique_id, id2, caste, nest, floral_host, notes)
df_flt_mola <- df_mola %>%
dplyr::select(un_id, vial_top, caste, nectar_plant, notes) %>%
rename(unique_id = vial_top, id2 = un_id, floral_host = nectar_plant) %>%
mutate(unique_id = as.character(unique_id),
nest = NA_character_,
id2 = NA_character_) %>%
dplyr::select(unique_id, id2, caste, nest, floral_host, notes)
df_collectors_mrg <- bind_rows(df_flt_boone, df_flt_hepner, df_flt_jean, df_flt_kochanski, df_flt_mola, df_flt_watson, df_flt_runquist) %>%
mutate(nest = if_else(floral_host %in% c("nest", "entering nest", "leaving nest"), "nest", nest),
floral_host = if_else(floral_host %in% c("nest", "entering nest", "leaving nest"), NA_character_, floral_host)) %>%
replace_with_na_all(condition = ~.x %in% common_na_strings) %>%
# why did I add this "attached" column? Great documentation, John.
mutate(attached = "attached")
# SOME WRANGLING TO 2021 DATA  --------------------------------------------
#TODO - Some values are duplicated. Search for dupes and missing values
#CLEAN - these are the duplicated values, for now I have simply removed all instances as we cannot be sure what is the "true" one or if they came from separate specimens or what:
v_dupes <- c("jmk-12jul21-01", "jmk-12jul21-02")
df_flt_2021_meta <- df_raw_USDA_meta %>%
mutate(year = year(caught_dd_mmm_yyyy)) %>%
inner_join(., df_collectors_mrg, by = c("sample_tube_id_with_description" = "unique_id")) %>%
filter(sample_tube_id_with_description %ni% v_dupes) %>%
rename(longname = sample_tube_id_with_description,
sex = male_m_female_f_unk,
date = caught_dd_mmm_yyyy,
from_nest = nest,
site = site_description_name)
# MERGE 2021 WITH 2020 ----------------------------------------------------
#CHECK - this is weird because the 2020 data is entirely from its own metadata file and the 2021 data is from the USDA mostly and then combined with a bit of collector data. Potentially for 2020 we want to pull only the relevant columns (nest, floral associations, notes) and an ID column and then join them....
## --> I think this ends up being fine as this was previously sorted. Just join the barcode for reference.
df_USDA_codes <- df_raw_USDA_meta %>%
select(internal_barcode, sample_tube_id_with_description)
df_partial_2020_meta <- dplyr::select(df_2020_meta, longname, sex, from_nest, which_nest, latitude, longitude, state, county, year, date, site_longname) %>%
rename(site = site_longname) %>%
mutate(floral_host = NA_character_)
df_partial_2021_meta <- df_flt_2021_meta %>%
dplyr::select(longname, sex, from_nest, latitude, longitude, state, county, year, date, site, floral_host) %>%
mutate(latitude = as.numeric(latitude),
longitude = as.numeric(longitude))
#This merge ends up containing missing 10 specimens that are in the USDA database but do not have appropriate metadata. 4 are the duplicates from Jade's collections (with no real way of figuring out exactly where they came from), 1 is an untracked specimen from Elaine (similarly with no real way of knowing whats up), but the remaining five are from Jay. There's a chance some of them are from the known nest...so for now, this seems like an appropriate list.
df_meta_merged <- bind_rows(df_partial_2020_meta, df_partial_2021_meta) %>%
inner_join(., df_USDA_codes, by = c("longname" = "sample_tube_id_with_description")) %>%
filter(year > 2019)
saveRDS(df_meta_merged, file = "./data/data_output/df_rpbb_metadata_01a_output.R")
##%######################################################%##
#                                                          #
####           SECOND DATA WRANGLING FILE FOR           ####
####     2020/2021 RPBB POPULATION GENETICS PROJECT     ####
#                                                          #
##%######################################################%##
# The purpose of this document is to continue the wrangling of the 2020/2021 RPBB genetic data. Within this document, we dileate populations, ensure consistent naming of sites, states, etc, and check that our lat-long coordinates are true and not obscured records (which is done to protect locations of sensitive pop'ns or private landowners).
# Things to do in this document
#TODO - ensure specimens have real lat-long and not obscured, if obscured get real and merge
#TODO - plot everything on a map and make sure they are as expected (go back and make corrections as necessary)
#TODO group nearby specimens into "populations" (not sure of the smartest way to do this...)
# Things to do in the next document
#TODO - merge genotype data with the output of this document
#TODO - add a loci count and other quality check columns as needed
#TODO - ensure output is ready to be converted to required files for COLONY
# PACKAGES ----------------------------------------------------------------
library(tidyverse)
library(readxl)
library(janitor)
library(lubridate)
library(naniar)
`%ni%` <- Negate(`%in%`)
# DATA --------------------------------------------------------------------
df_meta <- readRDS("./data/data_output/df_rpbb_metadata_01a_output.R")
# VARIOUS NAME STANDARDIZATION --------------------------------------------
# Below, I want to wrangle to ensure consistent naming in sex, state, county, site, and floral_host (i.e. no redundant names or different names for the same thing)
# Consistent SEX labels ---
# For females there is "f", "female", and "worker"
# there are NO gynes in the dataset, so caste is unnecessary
# For males there is "m" "male" and "Male"
# There are 5 NAs for some reason...
#TODO - !!!!!!!!!!!!FOR NOW WE EXCLUDE THE NA SEX INDIVIDUALS!!!!!!!!!!!!!!!
v_males <- c("m", "male", "Male")
v_females <- c("f", "female", "Worker")
# Consistent STATE labels ---
v_wisconsin <- c("WI", "wisconsin")
v_illinois <- c("IL", "Illinois")
v_iowa <- c("IA", "IO", "Iowa")
v_minnesota <- c("minnesota", "Minnesota", "MN")
v_virginia <- c("Virginia")
v_west_virginia <- c("West Virginia", "WV")
# Consistent COUNTY labels ---
# the only issues with counties seem to be capitalization, so I just add that to the wrangling below
# Consistent SITE labels ---
# actually...I'm not sure this really matters and it's kinda a pain. If it matters down the line, I'll do it. But for now, I should probably focus on doing smarter things like measuring the distance between everyone and then clustering them
# Consistent FLORAL_HOST labels
# done below as it's a lot...
# The actual wrangling step; doing it kinda in a redundant way for better readability IMO
df_wrg_meta <- df_meta %>%
# SEX names and filter
mutate(sex = case_when(
sex %in% v_males ~ "male",
sex %in% v_females ~ "female",
sex == "NA" ~ NA_character_
)) %>%
filter(!is.na(sex)) %>%
# STATE names
mutate(state = case_when(
state %in% v_wisconsin ~ "wisconsin",
state %in% v_illinois ~ "illinois",
state %in% v_iowa ~ "iowa",
state %in% v_minnesota ~ "minnesota",
state %in% v_virginia ~ "virginia",
state %in% v_west_virginia ~ "west virginia",
TRUE ~ NA_character_
)) %>%
# COUNTY names
mutate(county = tolower(county)) %>%
mutate(floral_host = case_when(
floral_host == "agastache foeniculum" ~ "Agastache foeniculum",
floral_host == "astilbe" ~ "Astilbe sp.",
floral_host == "Cirsium species" ~ "Cirsium sp.",
floral_host == "Daucus carota" ~ "Daucus carrota",
floral_host == "eutrochium purpureum" ~ "Eurtrochium purpureum",
floral_host == "linaria vulgaris" ~ "Linaria vulgaris",
floral_host == "lotus corniculatus" ~ "Lotus corniculatus",
floral_host == "melilotus albus" ~ "Melilotus albus",
floral_host == "monarda fistulosa" ~ "Monarda fistulosa",
floral_host %in% c("pycanthemum", "Pycnanthemum (virginiana or tenuiflora)", "pycnanthemum virginianum", "Pycnanthemum virginianum") ~ "Pycnanthemum sp.",
floral_host == "Rudbeckia laciniata 'Goldkugel'" ~ "Rudbeckia laciniata",
floral_host == "securigera varia" ~ "Securigera varia",
floral_host == "sorbaria sorbifolia" ~ "Sorbaria sorbifolia",
floral_host == "teucrium canadense" ~ "Teucrium canadense",
floral_host == "thalictrum" ~ "Thalictrum sp.",
floral_host == "Unknown" ~ NA_character_,
floral_host == "vicia americana" ~ "Vicia americana",
floral_host == "in flight" ~ NA_character_,
TRUE ~ floral_host
)) %>%
separate(col = floral_host, into = c("fl_genus", "fl_species"), sep = " ", extra = "merge")
saveRDS(df_wrg_meta, "./data/data_output/df_rpbb_metadata_01b_output.R")
library(sp)
library(rgdal)
library(geosphere)
install.packages("geosphere")
library(geosphere)
# example data from the thread
x <- c(-1.482156, -1.482318, -1.482129, -1.482880, -1.485735, -1.485770, -1.485913, -1.484275, -1.485866)
y <- c(54.90083, 54.90078, 54.90077, 54.90011, 54.89936, 54.89935, 54.89935, 54.89879, 54.89902)
# convert data to a SpatialPointsDataFrame object
xy <- SpatialPointsDataFrame(
matrix(c(x,y), ncol=2), data.frame(ID=seq(1:length(x))),
proj4string=CRS("+proj=longlat +ellps=WGS84 +datum=WGS84"))
# use the distm function to generate a geodesic distance matrix in meters
mdist <- distm(xy)
# cluster all points using a hierarchical clustering approach
hc <- hclust(as.dist(mdist), method="complete")
# define the distance threshold, in this case 40 m
d=40
# define clusters based on a tree "height" cutoff "d" and add them to the SpDataFrame
xy$clust <- cutree(hc, h=d)
##%######################################################%##
#                                                          #
####             SPATIAL DATA CLUSTERING OF             ####
####            POINTS TO ASSIGN POPULATIONS            ####
#                                                          #
##%######################################################%##
#PURPOSE - to take the metadata with lat-long and assign them to clusters based on some threshold rule of distance. This seems preferable to assigning to population based on some more arbitrary metric (like county or just...my decision)
# Things to do in this document
#TODO - ensure specimens have real lat-long and not obscured, if obscured get real and merge
#TODO - plot everything on a map and make sure they are as expected (go back and make corrections as necessary)
#TODO group nearby specimens into "populations" (not sure of the smartest way to do this...)
### Going to try to follow the StackOverflow page here: https://gis.stackexchange.com/questions/17638/clustering-spatial-data-in-r
# Things to do in the next document
#TODO - merge genotype data with the output of this document
#TODO - add a loci count and other quality check columns as needed
#TODO - ensure output is ready to be converted to required files for COLONY
library(sp)
library(rgdal)
library(geosphere)
# example data from the thread
x <- c(-1.482156, -1.482318, -1.482129, -1.482880, -1.485735, -1.485770, -1.485913, -1.484275, -1.485866)
y <- c(54.90083, 54.90078, 54.90077, 54.90011, 54.89936, 54.89935, 54.89935, 54.89879, 54.89902)
# convert data to a SpatialPointsDataFrame object
xy <- SpatialPointsDataFrame(
matrix(c(x,y), ncol=2), data.frame(ID=seq(1:length(x))),
proj4string=CRS("+proj=longlat +ellps=WGS84 +datum=WGS84"))
# use the distm function to generate a geodesic distance matrix in meters
mdist <- distm(xy)
# cluster all points using a hierarchical clustering approach
hc <- hclust(as.dist(mdist), method="complete")
# define the distance threshold, in this case 40 m
d=40
# define clusters based on a tree "height" cutoff "d" and add them to the SpDataFrame
xy$clust <- cutree(hc, h=d)
library(dismo)
library(rgeos)
install.packages("dismo")
install.packages("rgeos")
library(dismo)
library(rgeos)
# expand the extent of plotting frame
xy@bbox[] <- as.matrix(extend(extent(xy),0.001))
# get the centroid coords for each cluster
cent <- matrix(ncol=2, nrow=max(xy$clust))
for (i in 1:max(xy$clust))
# gCentroid from the rgeos package
cent[i,] <- gCentroid(subset(xy, clust == i))@coords
# compute circles around the centroid coords using a 40m radius
# from the dismo package
ci <- circles(cent, d=d, lonlat=T)
# plot
plot(ci@polygons, axes=T)
plot(xy, col=rainbow(4)[factor(xy$clust)], add=T)
xy
library(sf)
as.data.frame(xy)
library(tidyverse)
df_meta <- readRDS("./data/data_output/df_rpbb_metadata_01b_output.R")
names(df_meta)
df_meta2=rename(df_meta, x=longitude,y=latitude)
# Transforming mw15 into UTM -----
geo_meta <- st_as_sf(df_meta2, coords = c("x", "y"), crs = 4326)
df_meta2=rename(df_meta, x=longitude,y=latitude) %>%
filter(!is.na(x))
# Transforming mw15 into UTM -----
geo_meta <- st_as_sf(df_meta2, coords = c("x", "y"), crs = 4326)
# Transforming mw15 into UTM -----
geo_meta <- st_as_sf(df_meta2, coords = c("x", "y"), crs = 4326)
geo_meta2<-st_transform(x = geo_meta, crs = 32610) # this not best UTM but it works for now
geo_meta
geo_meta2
View(geo_meta)
geo_meta2<-st_transform(x = geo_meta, crs = 32616) # ask Amy about doing these steps
geo_mq_all$lon<-st_coordinates(geo_mq_all)[,1] # get coordinates
geo_mq_all$lat<-st_coordinates(geo_mq_all)[,2] # get coordinates
geo_meta2$lon<-st_coordinates(geo_meta2)[,1] # get coordinates
geo_meta2$lat<-st_coordinates(geo_meta2)[,2] # get coordinates
geo_meta3<-st_set_geometry(geo_meta2, NULL)
geo_meta3
View(geo_meta3)
# Transforming mw15 into UTM -----
geo_meta <- st_as_sf(df_meta2, coords = c("x", "y"), crs = 4326)
# convert data to a SpatialPointsDataFrame object
xy <- SpatialPointsDataFrame(
matrix(c(x,y), ncol=2), data.frame(ID=seq(1:length(x))),
proj4string=CRS("+proj=longlat +ellps=WGS84 +datum=WGS84"))
View(xy)
xy@data[["ID"]]
# convert data to a SpatialPointsDataFrame object
xy <- SpatialPointsDataFrame(
matrix(c(x,y), ncol=2), data.frame(ID=seq(1:length(geo_meta))),
proj4string=CRS("+proj=longlat +ellps=WGS84 +datum=WGS84"))
?SpatialPointsDataFrame
geo_meta
# use the distm function to generate a geodesic distance matrix in meters
mdist <- distm(geo_meta)
mtx_distance <- st_distance(geo_meta, geo_meta)
mtx_distance
# cluster all points using a hierarchical clustering approach
hc <- hclust(as.dist(mtx_distance), method="complete")
# define the distance threshold, in this case 40 m
d=10000
# define clusters based on a tree "height" cutoff "d" and add them to the SpDataFrame
geo_meta$clust <- cutree(hc, h=d)
View(geo_meta)
geo_meta2<-st_transform(x = geo_meta, crs = 32616) # ask Amy about doing these steps
geo_meta2$lon<-st_coordinates(geo_meta2)[,1] # get coordinates
geo_meta2$lat<-st_coordinates(geo_meta2)[,2] # get coordinates
geo_meta3<-st_set_geometry(geo_meta2, NULL)
mtx_distance <- st_distance(geo_meta3, geo_meta3)
geo_meta3
geo_meta2
df_meta <- readRDS("./data/data_output/df_rpbb_metadata_01b_output.R")
df_meta2=rename(df_meta, x=longitude,y=latitude) %>%
#TODO - !!!!!!!! NOTE!!!!!!!!! I HAD TO FILTER OUT THE SPECIMENS WITH MISSING LAT-LONG!!!!!!
filter(!is.na(x))
# Transforming mw15 into UTM -----
geo_meta <- st_as_sf(df_meta2, coords = c("x", "y"), crs = 4326)
geo_meta2<-st_transform(x = geo_meta, crs = 32616) # ask Amy about doing these steps
geo_meta2$lon<-st_coordinates(geo_meta2)[,1] # get coordinates
geo_meta2$lat<-st_coordinates(geo_meta2)[,2] # get coordinates
mtx_distance <- st_distance(geo_meta2, geo_meta2)
# cluster all points using a hierarchical clustering approach
hc <- hclust(as.dist(mtx_distance), method="complete")
# define the distance threshold, in this case 40 m
d=10000
# define clusters based on a tree "height" cutoff "d" and add them to the SpDataFrame
geo_meta2$clust <- cutree(hc, h=d)
View(geo_meta2)
df_affinis_historic <- read_csv("./data/data_raw/meta_rpbb_external/rpbb_historic_counties.csv")  %>% clean_names()
library(janitor)
df_affinis_historic <- read_csv("./data/data_raw/meta_rpbb_external/rpbb_historic_counties.csv")  %>% clean_names()
v_historic_states <- df_affinis_historic %>% distinct(state) %>% pull(state)
bg_map <- st_as_sf(map("state", regions = v_historic_states, plot = FALSE, fill = TRUE))
bg_map <- st_as_sf(map("state", regions = v_historic_states, plot = FALSE, fill = TRUE))
library(sf)
library(maps)
bg_map <- st_as_sf(map("state", regions = v_historic_states, plot = FALSE, fill = TRUE))
p_map <- ggplot() +
geom_sf(data = bg_map, fill = "antiquewhite", alpha = 0.4, color = "grey80", size = 0.4) +
#geom_sf(data = bg_map_extant, fill = "grey", alpha = 0.5, color = "grey80", size = 0.4, aes(text = ID)) +
geom_jitter(data = df_rpbb_geno, aes(x = longitude, y = latitude, fill = reg_site), alpha = 0.5, color = "black", shape = 21, size = 2) +
annotation_scale(location = "bl", width_hint = 0.4) +
annotation_north_arrow(location = "bl", which_north = "true",
pad_x = unit(0.1, "in"), pad_y = unit(0.3, "in"),
style = north_arrow_fancy_orienteering) +
theme_bw() +
theme(panel.grid.major = element_line(color = gray(0.9),
linetype = "dashed",
size = 0.2),
panel.background = element_rect(fill = "white"),
legend.position = "right") +
labs(x = "", y = "", fill = "Region")
p_map <- ggplot() +
geom_sf(data = bg_map, fill = "antiquewhite", alpha = 0.4, color = "grey80", size = 0.4) +
#geom_sf(data = bg_map_extant, fill = "grey", alpha = 0.5, color = "grey80", size = 0.4, aes(text = ID)) +
geom_jitter(data = geo_meta2, aes(x = lon, y = lat, fill = clust), alpha = 0.5, color = "black", shape = 21, size = 2) +
annotation_scale(location = "bl", width_hint = 0.4) +
annotation_north_arrow(location = "bl", which_north = "true",
pad_x = unit(0.1, "in"), pad_y = unit(0.3, "in"),
style = north_arrow_fancy_orienteering) +
theme_bw() +
theme(panel.grid.major = element_line(color = gray(0.9),
linetype = "dashed",
size = 0.2),
panel.background = element_rect(fill = "white"),
legend.position = "right") +
labs(x = "", y = "", fill = "Region")
p_map <- ggplot() +
geom_sf(data = bg_map, fill = "antiquewhite", alpha = 0.4, color = "grey80", size = 0.4) +
#geom_sf(data = bg_map_extant, fill = "grey", alpha = 0.5, color = "grey80", size = 0.4, aes(text = ID)) +
geom_jitter(data = geo_meta2, aes(x = lon, y = lat, fill = clust), alpha = 0.5, color = "black", shape = 21, size = 2) +
# annotation_scale(location = "bl", width_hint = 0.4) +
# annotation_north_arrow(location = "bl", which_north = "true",
#                        pad_x = unit(0.1, "in"), pad_y = unit(0.3, "in"),
#                        style = north_arrow_fancy_orienteering) +
theme_bw() +
theme(panel.grid.major = element_line(color = gray(0.9),
linetype = "dashed",
size = 0.2),
panel.background = element_rect(fill = "white"),
legend.position = "right") +
labs(x = "", y = "", fill = "Region")
p_map
p_map <- ggplot() +
geom_sf(data = bg_map, fill = "antiquewhite", alpha = 0.4, color = "grey80", size = 0.4) +
#geom_sf(data = bg_map_extant, fill = "grey", alpha = 0.5, color = "grey80", size = 0.4, aes(text = ID)) +
geom_jitter(data = geo_meta2, aes(x = lon, y = lat, fill = clust), alpha = 0.5, color = "black", shape = 21, size = 2) +
# annotation_scale(location = "bl", width_hint = 0.4) +
# annotation_north_arrow(location = "bl", which_north = "true",
#                        pad_x = unit(0.1, "in"), pad_y = unit(0.3, "in"),
#                        style = north_arrow_fancy_orienteering) +
theme_bw() +
theme(panel.grid.major = element_line(color = gray(0.9),
linetype = "dashed",
size = 0.2),
panel.background = element_rect(fill = "white"),
legend.position = "right") +
labs(x = "", y = "", fill = "Region")
p_map
p_map <- ggplot() +
geom_sf(data = bg_map, fill = "antiquewhite", alpha = 0.4, color = "grey80", size = 0.4) +
#geom_sf(data = bg_map_extant, fill = "grey", alpha = 0.5, color = "grey80", size = 0.4, aes(text = ID)) +
geom_jitter(data = geo_meta2, aes(x = lon, y = lat, fill = clust), alpha = 0.5, color = "black", shape = 21, size = 2) +
# annotation_scale(location = "bl", width_hint = 0.4) +
# annotation_north_arrow(location = "bl", which_north = "true",
#                        pad_x = unit(0.1, "in"), pad_y = unit(0.3, "in"),
#                        style = north_arrow_fancy_orienteering) +
theme_bw() +
theme(panel.grid.major = element_line(color = gray(0.9),
linetype = "dashed",
size = 0.2),
panel.background = element_rect(fill = "white"),
legend.position = "right")
ggplot() +
geom_sf(data = bg_map, fill = "antiquewhite", alpha = 0.4, color = "grey80", size = 0.4)
mtx_distance <- st_distance(geo_meta, geo_meta)
# cluster all points using a hierarchical clustering approach
hc <- hclust(as.dist(mtx_distance), method="complete")
# define the distance threshold, in this case 40 m
d=10000
# define clusters based on a tree "height" cutoff "d" and add them to the SpDataFrame
geo_meta$clust <- cutree(hc, h=d)
View(geo_meta)
df_geo <- as.data.frame(geo_meta)
View(df_geo)
df_goe
df_geo
geo_meta
df_geo <-st_set_geometry(geo_meta, NULL)
p_map <- ggplot() +
geom_sf(data = bg_map, fill = "antiquewhite", alpha = 0.4, color = "grey80", size = 0.4) +
#geom_sf(data = bg_map_extant, fill = "grey", alpha = 0.5, color = "grey80", size = 0.4, aes(text = ID)) +
geom_jitter(data = geo_meta, aes(x = lon, y = lat, fill = clust), alpha = 0.5, color = "black", shape = 21, size = 2) +
# annotation_scale(location = "bl", width_hint = 0.4) +
# annotation_north_arrow(location = "bl", which_north = "true",
#                        pad_x = unit(0.1, "in"), pad_y = unit(0.3, "in"),
#                        style = north_arrow_fancy_orienteering) +
theme_bw() +
theme(panel.grid.major = element_line(color = gray(0.9),
linetype = "dashed",
size = 0.2),
panel.background = element_rect(fill = "white"),
legend.position = "right")
p_map
df_geo
View(df_geo)
df_geo <-st_set_geometry(geo_meta, NULL) %>%
inner_join(., df_meta)
View(df_geo)
p_map <- ggplot() +
geom_sf(data = bg_map, fill = "antiquewhite", alpha = 0.4, color = "grey80", size = 0.4) +
#geom_sf(data = bg_map_extant, fill = "grey", alpha = 0.5, color = "grey80", size = 0.4, aes(text = ID)) +
geom_jitter(data = geo_meta, aes(x = longitude, y = latitude, fill = clust), alpha = 0.5, color = "black", shape = 21, size = 2) +
# annotation_scale(location = "bl", width_hint = 0.4) +
# annotation_north_arrow(location = "bl", which_north = "true",
#                        pad_x = unit(0.1, "in"), pad_y = unit(0.3, "in"),
#                        style = north_arrow_fancy_orienteering) +
theme_bw() +
theme(panel.grid.major = element_line(color = gray(0.9),
linetype = "dashed",
size = 0.2),
panel.background = element_rect(fill = "white"),
legend.position = "right")
p_map
p_map <- ggplot() +
geom_sf(data = bg_map, fill = "antiquewhite", alpha = 0.4, color = "grey80", size = 0.4) +
#geom_sf(data = bg_map_extant, fill = "grey", alpha = 0.5, color = "grey80", size = 0.4, aes(text = ID)) +
geom_jitter(data = geo_meta, aes(x = longitude, y = latitude, fill = clust), alpha = 0.5, color = "black", shape = 21, size = 2) +
# annotation_scale(location = "bl", width_hint = 0.4) +
# annotation_north_arrow(location = "bl", which_north = "true",
#                        pad_x = unit(0.1, "in"), pad_y = unit(0.3, "in"),
#                        style = north_arrow_fancy_orienteering) +
theme_bw() +
theme(panel.grid.major = element_line(color = gray(0.9),
linetype = "dashed",
size = 0.2),
panel.background = element_rect(fill = "white"),
legend.position = "right")
p_map
p_map <- ggplot() +
geom_sf(data = bg_map, fill = "antiquewhite", alpha = 0.4, color = "grey80", size = 0.4) +
#geom_sf(data = bg_map_extant, fill = "grey", alpha = 0.5, color = "grey80", size = 0.4, aes(text = ID)) +
geom_jitter(data = df_geo, aes(x = longitude, y = latitude, fill = clust), alpha = 0.5, color = "black", shape = 21, size = 2) +
# annotation_scale(location = "bl", width_hint = 0.4) +
# annotation_north_arrow(location = "bl", which_north = "true",
#                        pad_x = unit(0.1, "in"), pad_y = unit(0.3, "in"),
#                        style = north_arrow_fancy_orienteering) +
theme_bw() +
theme(panel.grid.major = element_line(color = gray(0.9),
linetype = "dashed",
size = 0.2),
panel.background = element_rect(fill = "white"),
legend.position = "right")
p_map
library(ggplotly)
install.packages("plotly")
library(plotly)
ggplotly(p_map)
df_geo %>% count(clust)
df_geo %>% count(clust) %>% View()
# define the distance threshold, in this case 40 m
d=20000
# define clusters based on a tree "height" cutoff "d" and add them to the SpDataFrame
geo_meta$clust <- cutree(hc, h=d)
df_geo <-st_set_geometry(geo_meta, NULL) %>%
inner_join(., df_meta)
df_affinis_historic <- read_csv("./data/data_raw/meta_rpbb_external/rpbb_historic_counties.csv")  %>% clean_names()
v_historic_states <- df_affinis_historic %>% distinct(state) %>% pull(state)
bg_map <- st_as_sf(map("state", regions = v_historic_states, plot = FALSE, fill = TRUE))
p_map <- ggplot() +
geom_sf(data = bg_map, fill = "antiquewhite", alpha = 0.4, color = "grey80", size = 0.4) +
#geom_sf(data = bg_map_extant, fill = "grey", alpha = 0.5, color = "grey80", size = 0.4, aes(text = ID)) +
geom_jitter(data = df_geo, aes(x = longitude, y = latitude, fill = clust), alpha = 0.5, color = "black", shape = 21, size = 2) +
# annotation_scale(location = "bl", width_hint = 0.4) +
# annotation_north_arrow(location = "bl", which_north = "true",
#                        pad_x = unit(0.1, "in"), pad_y = unit(0.3, "in"),
#                        style = north_arrow_fancy_orienteering) +
theme_bw() +
theme(panel.grid.major = element_line(color = gray(0.9),
linetype = "dashed",
size = 0.2),
panel.background = element_rect(fill = "white"),
legend.position = "right")
ggplotly(p_map)
df_geo %>% count(clust)
df_geo %>% count(clust) %>% View
df_geo %>% group_by(clust, state) %>% tally()
df_geo %>% group_by(clust, state) %>% tally() %>% View()
df_geo %>% group_by(clust, state) %>% tally() %>% group_by(clust) %>% add_tally()
df_geo %>% group_by(clust, state) %>% tally() %>% group_by(clust) %>% add_tally() %>% View()
